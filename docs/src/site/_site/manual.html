<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Remotely Documentation - Manual</title>

    <link rel="stylesheet" href="/css/styles.css">
    <link rel="stylesheet" href="/css/custom.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <a name="top"></a>
    <div class="wrapper">
      <header>
        <h1>Remotely</h1>
        <p>Last updated on <em>January 30, 2015</em></p>

        <ul>
          <li><a href="https://github.com/oncue/remotely/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/oncue/remotely/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/oncue/remotely">View On <strong>GitHub</strong></a></li>
        </ul>

        <hr />

        <ol id="top">
          <!-- home -->
          <li><a href="/">Home</a></li>
          

          <li><a href="/manual.html">Manual</a></li>
          
            <li>
              <ol class="menu">
                <li><a href="/manual.html#codecs">Codecs</a></li>
                <li><a href="/manual.html#references">Remotes</a></li>
                <li><a href="/manual.html#endpoint">Endpoints</a></li>
                <li><a href="/manual.html#resiliancy">Resiliancy</a></li>
                <li><a href="/manual.html#execution-context">Execution Context</a></li>
                <li><a href="/manual.html#monitoring">Monitoring</a></li>
                <li><a href="/manual.html#responses">Responses</a></li>
              </ol>
            </li>
          


          <li><a href="/internals.html">Internals</a></li>
          
        </ol>

        <hr />

      </header>
      <section>
        <h1>Manual</h1>

<p><em>Remotely</em> is a sophisticated but simple system. There are a few core concepts and then a set of associated details. Some of these details are important to know, and others might just catch your interest. </p>

<p><a name="codecs"></a></p>

<h2>Codecs</h2>

<p>One of the most important elements of <em>Remotely</em> is its fast, lightweight serialisation system built atop <a href="https://github.com/scodec/scodec">Scodec</a>. This section reviews the default behavior that ships with <em>Remotely</em> and then explains how to extend these with your own custom codecs if needed.</p>

<p>By default, <em>Remotely</em> ships with the ability to serialise / deserialise the following &quot;primitive&quot; types:</p>

<ul>
<li><code>A \/ B</code> (scalaz.\/, otherwise known as a disjunction)</li>
<li><code>Array[Byte]</code></li>
<li><code>Boolean</code></li>
<li><code>Double</code></li>
<li><code>Either[A,B]</code></li>
<li><code>Float</code></li>
<li><code>IndexedSeq[A]</code></li>
<li><code>Int</code> (both 32 and 64)</li>
<li><code>List[A]</code></li>
<li><code>Map[A,B]</code></li>
<li><code>Option[A]</code></li>
<li><code>Set[A]</code></li>
<li><code>SortedMap[A,B]</code></li>
<li><code>SortedSet[A]</code></li>
<li><code>String</code> (encoded with UTF8)</li>
<li><code>Tuple2...7</code></li>
<li><code>remotely.Response.Context</code></li>
</ul>

<p>Often these built-in defaults will be all you need, but there might be times where it feels like it would be more appropriate do provide a &quot;wire type&quot; (that is, a datatype that represents the external wire API - <strong>NOT</strong> a data type that forms part of your core domain model). Typically this happens when you have a convoluted structure or a very &quot;stringly-typed&quot; interface (e.g. <code>Map[String, Map[String, Int]]</code> - who knows what on earth the author intended here!). In this cases, implementing custom codecs for your protocol seems attractive, and fortunatly its really simple to do:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">package oncue.example

import remotely.codecs._
import scodec.{Codec,codecs =&gt; C}
import scodec.bits.BitVector
import java.nio.charset.Charset

case class ComponentW(kind: String, metadata: Map[String,String])

package object myapp {

  implicit val charset: Charset = Charset.forName(&quot;UTF-8&quot;)

  implicit val componentCodec: Codec[ComponentW] =
    (utf8 ~~ map[String,String]).pxmap(
      ComponentW.apply,
      ComponentW.unapply
    )
}
</code></pre></div>
<p>In this example, <code>ComponentW</code> is part of our wire protocol definition, and provides some application-specific semantic that is meaningful for API consumers (assuming the fields <code>kind</code> and <code>metadata</code> have &quot;meaning&quot; together). To make this item serializable, we simply need to tell scodec about the <em>shape</em> of the structure (in this case, <code>String</code> and <code>Map[String,String]</code>) and then supply a function <code>Shape =&gt; A</code> and then <code>A =&gt; Option[(Shape)]</code>. At runtime <em>Remotely</em> will use this codec to take the bytes from the wire and convert it into the <code>ComponentW</code> datatype using the defined shape and the associated fucntions.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">// TODO: add more sophisticated examples?
</code></pre></div>
<p><a name="references"></a></p>

<h2>Remotes</h2>

<p>One of the interesting design points with <em>Remotely</em> is that remote server functions are modeled as local functions using a &quot;remote reference&quot;. That&#39;s quite an opaque statement, so let&#39;s illustrate it with an example:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">import remotely._

Remote.ref[Int =&gt; Int](&quot;factorial&quot;)
</code></pre></div>
<p>Notice how this is <em>just a reference</em> - it doesnt actually <em>do</em> anything. At this point we have told the system that here&#39;s an immutable handle to a function that <em>might</em> later be avalbile on an arbitrary endpoint, and the type of function being provided is <code>Int =&gt; Int</code> and its name is &quot;factorial&quot;. This is interesting (and useful) because it entirely decouples the understanding about a given peice of functionality on the client side, and the system actor that will ultimatly fulfil that request. <em>Remotely</em> clients will automatically model the server functions in this manner, so lets take a look at actually caling one of these functions:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">scala&gt; FactorialClient.factorial(1)
&lt;console&gt;:11: error: type mismatch;
 found   : Int(1)
 required: remotely.Remote[Int]
              FactorialClient.factorial(1)
</code></pre></div>
<p>That didnt go as planned! As it turns out, <code>Remote</code> function references can only be applied using values that have been explicitly lifted into a <code>Remote</code>  context, and <em>Remotely</em> comes with several convenient combinators to do that:</p>

<ul>
<li><p><code>Remote.local</code>: given a total value, simply lift it directly into a <code>Remote</code> instance. This is the most simplistic form of the <code>Remote</code> API, and is useful in many cases; especially for testing.</p></li>
<li><p><code>Remote.async</code>: given a value <code>A</code> that is computed from some <code>Task[A]</code>, execute the <code>Task</code> and turn the value into a <code>Remote[A]</code>. For example, perhaps you lookup a value from a database and want to call a remote service with that given value, this is a convenient combinator for just such a case.</p></li>
<li><p><code>Remote.response</code>: Given a <code>Response</code> from another remote function execution (more on <code>Remote</code> shortly), use it as the input to this remote function. This is incredibly useful for chaining calls to dependant systems.</p></li>
</ul>

<p>You can choose to either use these functions directly, or have them implciitly applied by adding the following implicit conversion:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">import remotely._, codecs._, Remote.implicits._
</code></pre></div>
<p>With this in scope, these functions will be automatically applied. One word of caution: you must ensure that you have a <code>Codec</code> in scope for whatever <code>A</code> you are trying to convert to a <code>Remote</code> value.</p>

<p><a name="endpoint"></a></p>

<h2>Endpoints</h2>

<p>Now that you have a <code>Remote</code> function and you know how to apply arguments (applying the function inside the <code>Remote</code> monad), we need to explore the next important primitive in <em>Remotely</em>: <code>Endpoint</code>. An <code>Endpoint</code> models the network locaiton of a specific server on a specific TCP port which can service function calls. Internally, <code>Endpoint</code> instances are modeled as a stream of <code>Endpoint</code>; doing this allows for a range of flexiblity around circuit breaking and load balencing. Users can either embrace this <code>Process[Task, Endpoint.Connection]</code> directly, or use some of the convenience functions outlined below:</p>

<ul>
<li><p><code>Endpoint.empty</code>: create an empty endpoint, with no reachable locations in the stream.</p></li>
<li><p><code>Endpoint.single</code>: Create an endpoint representing a single IP:PORT location of a <em>Remotely</em> service. </p></li>
<li><p><code>Endpoint.singleSSL</code>: Does the same as <code>single</code>, with the addition of using transport layer security (specifically, TLS1.2) </p></li>
</ul>

<p>Using these basic combinators, we can now execute the <code>Remote</code> against a given endpoint. In order to do this, you have to elect what &quot;context&quot; the remote call will carry with it. </p>

<p><a name="resiliancy"></a></p>

<h3>Resiliancy</h3>

<p>In addition to the simpler functions outlined above, we have also built in some resilience functions around <code>Endpoint</code> to make working with large systems more practical. One of the most important resiliance functions on <code>Endpoint</code> is <code>circuitBroken</code>. This adds a <a href="http://martinfowler.com/bliki/CircuitBreaker.html">circuit breaker</a> to the endpoint. Consider the following usage example:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">// ADD EXAMPLE HERE
</code></pre></div>
<p>The followig are the primary functions of interest on the <code>Endpoint</code> object:</p>

<ul>
<li><p><code>Endpoint.roundRobin</code>: Given a set of <code>Endpoint</code>, <em>Remotely</em> can execute client-side load balencing when selecting a back-end to invoke over the network. Whilst the default is a simple round-robin, <em>Remotely</em> is plugable enough such that you could implement a much more sophisticated distribution algorithem without too much difficulty at all.</p></li>
<li><p><code>Endpoint.failoverChain</code></p></li>
<li><p><code>Endpoint.uber</code></p></li>
</ul>

<p><a name="execution-context"></a></p>

<h3>Execution Context</h3>

<p>A <code>Context</code> is essentially a primitive data type that allows a given function invokation to carry along some metadata. When designing <em>Remotely</em>, we envisinged the following use cases:</p>

<ul>
<li><p><em>Transitive Request Graphing</em>: in large systems, it becomes extreamly useful to understand which instances of any given service is actually taking traffic and what the call graph actually is from a given originating caller. In this frame, <code>Context</code> comes with a stack of request IDs which are generated on each roundtrip, and if service A calls service B, the caller of A will recive a stack of IDs that detnote the call all the way to B. Needless to say, this is incredibly useful for tracing, monitoring and debugging request graphs. </p></li>
<li><p><em>Experimentation</em>: The <code>Context</code> supports an arbitrary <code>Map[String,String]</code> of data that can be propagated along with the request for the purposes of experimentation (for example, an A/B testing token).</p></li>
</ul>

<p>Given any <code>Remote</code> function that you have applied, you can opt to execute it against an <code>Endpoint</code> with or without a context. Consider the following examples:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">import remotely._, codecs._, Response.Context

val address  = new InetSocketAddress(&quot;localhost&quot;, 8080)

val endpoint = Endpoint.single(address)(system)

val f: Remote[Int] = FactorialClient.reduce(2 :: 4 :: 8 :: Nil)

/******** without a context ********/

val t1: Task[Int] = f.runWithoutContext(endpoint)

/******** with a context ********/

val ctx = Context.empty.entries(&quot;foo&quot; -&gt; &quot;bar&quot;)

val t2: Task[Int] = f.runWithContext(endpoint, ctx)
</code></pre></div>
<p>If you elect to use a <code>Context</code> or not, the result is the same from the client perspecitve - contexts are simply a runtime value that can be propagated for use by the server or not.</p>

<p><a name="monitoring"></a></p>

<h3>Monitoring</h3>

<p>It&#39;s also worth noting at this point that when running a <code>Remote</code> with <code>runWithContext</code> or plain <code>run</code>, you have the option to pass in a <code>remotely.Monitoring</code> instance which will then be used to pass-in sampling information about the requests and responses being serviced by a <em>Remotely</em> service. Let&#39;s consider the <code>Monitoring</code> interface:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">trait Monitoring { self =&gt;
  /**
   * Invoked with the request, the request context,
   * the set of names referenced by that request,
   * the result, and how long it took.
   */
  def handled[A](
    ctx: Response.Context,
    req: Remote[A],
    references: Iterable[String],
    result: Throwable \/ A,
    took: Duration): Unit

  /**
   * Return a new `Monitoring` instance that send statistics
   * to both `this` and `other`.
   */
  def ++(other: Monitoring): Monitoring

  /**
   * Returns a `Monitoring` instance that records at most one
   * update for `every` elapsed duration.
   */
  def sample(every: Duration): Monitoring
}
</code></pre></div>
<p>As you can see, the interface is incredibly simple, and it serves two primary functions: </p>

<ol>
<li><p>To allow logging or tracing information to be dumped to a thrid-party system via the <code>handled</code> function, which contains the entire round-trip information.</p></li>
<li><p>To provide sampling information about the duration of requests being serviced by this endpoint implementation. </p></li>
</ol>

<p><a name="responses"></a></p>

<h2>SSL</h2>

<p>Endpoints can optionally be encrypted via SSL</p>

<h2>Responses</h2>

<p>When implementing a server...</p>

      </section>
      <footer>
        <p>This project is maintained by <a href="http://github.com/oncue">OnCue OSS</a>.
        <br/>Distributed under an <a href="http://www.apache.org/licenses/LICENSE-2.0.html" target="_blank">Apache 2.0 License.</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="/js/scale.fix.js" type="text/javascript"></script>
    <script type="text/javascript">
    //<![CDATA[
      var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
      document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
    //]]>
    </script>
    <script type="text/javascript">
    //<![CDATA[
      try {
        var pageTracker = _gat._getTracker("UA-57263411-1");
        pageTracker._trackPageview();
      } catch(err) {}
    //]]>
    </script>
  </body>
</html>
